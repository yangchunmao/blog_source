---
title: SVN 版本控制
tags: SVN
---

>如何通过SVN进行持续有效、方便易用的版本控制? 具体能够进行代码审核(需要人工进行判断,能够如`github`一样有同意`merge`的操作),可选择合并(同样需要人工判断);另,操作简单的分支合并,职责明确、简单清晰的分支定义.这是我们思考这个问题的目标.另,添加文档的管理.

#### 首先提出问题

+ 常用的通过`SVN`进行版本控制的开发模式有哪些?
+ 具体相关开发模式有哪些优点与缺点?
+ 目前项目下的SVN使用情况,存在哪些问题? 如何进行改进?
+ 应用改进后的开发流程,具体的实操步骤...


#### 常用的开发模式

+ 以`trunk`为主要开发目录

![trunk集中式开发模式](/img/svn图片/图片_trunk主干开发.png)

 职责说明:
 - `Trunk`: 用于开发人员各版本开发提交代码
 - `Tag`: 用于记录和保存每个`release`的代码
 - `Branch`: 用于`bug fixing`

这种方式为`trunk`集中式开发模式;
一般来说,所有的开发都是基于`trunk`进行开发的,当一个版本开发告一个段落(经过开发,测试,文档,打包等)结束后,代码处于冻结状态(人为规定,可以通过`hook`进行管理, 如何通过通过`hook`管理?).此时应该基于当前冻结的代码库,打`tag`.
当下一个版本/阶段的开发任务开始,继续在`trunk`上进行开发.如此这样对新需求/任务进行迭代.
此时,如果发现上一个已发行版本(`Released Version`)有一些`bug`,或者一些很急迫的功能要求,而正在开发的版本无法满足时间要求(进行一系列测试、开发等),这时候就需要在上一个版本上进行修改了.应该基于发行版对应的`tag`,做相应的分支`branch`进行开发.当`bug`/需求修正完成(同样经过开发,测试等),然后`merge`到`trunk`等待下一次发布.
这是一种很标准的开发模式,很多的公司都是采用这种模式进行开发.`trunk`永远是开发的主要目录.

+ 以`branch`为主要开发目录

![branch分散式开发模式](/img/svn图片/图片_branch分支开发.png)

 职责说明:
 - `Trunk`: 不承担具体的开发任务,只是承担版本发布
 - `Tag`: 用于记录和保存每个`release`的代码
 - `Branch`: 用于各版本开发目录,同时应对相应`bug fixing`

这种方式为`branch`分散式开始模式;
此模式中`trunk`不承担具体开发任务的,一个版本的开发任务在开始的时候,根据已经`released`的版本做新的开发`branch`,并且基于这个`branch`进行开发.当`branch`开发一个段落(经过开发,测试,文档,打包等),通过人工`merge`到`trunk`中进行版本发布,打`tag`.当下一个版本/阶段的开发任务开始,从当前`trunk`中打出另一个`branch`,进而对当前`branch`进行需求的迭代.更甚,如果当多个需求没有相关性时,可以同时打出多个`branch`并行开发迭代,这个可以再不影响其他团队的情况下,并行开发.当最后`merge`到`trunk`就会增加复杂度.
此时,如果发现上一个已发行版本有一些`bug`,或者一些很急迫的功能要求,还是在当前开发的`branch`上进行修改.但此时一定要注意如果当前分支的版本号已经低于`trunk`上的版本号,需要先合并`trunk`代码,再在`branch`上修改!

#### 版本开发流程的优缺点

+ 第一种开发模式(`trunk`集中式):
    - 优点: 管理简单.
    - 缺点: 当开发模块比较多,开发人员/小团队比较多时,很容易产生冲突而影响对方的开发.因为所有的改动都有可能触碰到对方的改动.另外没法通过`merge`进行过滤提交发版,还有代码的人工审核.   
+ 第二种开发模式(`branch`分散式):
    - 优点: 各自开发独立, 不容易相互影响.
    - 缺点: 管理复杂, 如果`branch`比较多,那么merge`的时候很麻烦.这个很费人力.
    

#### 当前项目`SVN`应用情况,如何流程化

当前我们项目`SVN`的`trunk`已经弃用,在一个`branch`上进行全量的开发,所有开发人员基于此`branch`进行提交修改,会导致没法管控各个开发人员的提交情况;并且发布测试没有可用的分支进行发布;且没有稳定版本的`tag`留档.
基于当前的现状及问题,总结常用的开发模式,做如下惯例:
- 基于当前`branch`的`HEAD revision`稳定版本做`tag`留档, 并以`tag`留档作为主要正式环境作为发版源
- 以`tag`留档打出主要的开发`branch`,命名为`_development`,作为对标集中式开发模式的`trunk`.
- 所有的基于`_development`分支的修改都经过测试等,验证需求完成.然后人工`merge`到`主branch`.
- `merge`有2种类型,`merge a range of revisions`: 选择一个或多个修订`merge`到当前目录;`merge two different trees`: 当希望将两个不同分支的差异合并到工作副本中时,应该此类型.
- 所有的`merge`都是把不同的`branch`或`branch`修订号合并到当前的`work coping`.
- `_development branch`的开发告一段落(进行详细的测试等), `merge`到发版`branch`,确定版本后打相应的`tag`留档.至此,主线开发流程就终结.
- 当已发布的`tag`存在问题,从当前`tag`打出分支进行`bug fixing`;如果需紧急修复,需`merge`到`tag`进行发布; 如果不是很紧急,可`merge`到`_development branch`进行下一次版本的发布。

#### 主要的技术要点

主要通过客户端工具`TortoiseSVN`进行相应的操作,最主要涉及到2个主要操作:
- 从某个`branch`打出`branch`或`tag`, `SVN`说白了就是目录管理,打分支/tag,其实就是目录拷贝
![TortoiseSVN-Branch/Tag操作](/img/svn图片/图片_打出分支.png)
- 把当前`branch`的某些改动`merge`当`work coping`,`merge`可以选择`merge`的深度,并可以进行`Test merge`
![TortoiseSVN-Merge...操作](/img/svn图片/图片_merge修改.png)
![TortoiseSVN-Merge自定义操作](/img/svn图片/图片_merge自定义.png)

至此,基本的`SVN`流程结构就理顺了,具体在后续的实际应用开发中出现其他问题再补充.另,`SVN`对开发文档方面的管理也要应用起来.文档的规范化(重点是建立相应文档的模板)更是需要很长的路要走!

----

附录:
 - 主目录: https://ump.haier.net/svn/RRSKX/branches/branch_mecv_v2.0_finance
 - 开发目录: https://ump.haier.net/svn/RRSKX/branches/branch_mecv_v2.0_finance_development
 - 文档目录: https://ump.haier.net/svn/RRSKX/doc/财务端/2018

----

思考:
 - 开发流程已经有了,那后续如何进行方便快捷的持续版本发布? 怎么实现通过`svn`、`docker`、`jenkins`进行持续集成?
